---
source: froql_macro/src/generator.rs
expression: result
---
let invar_1: Entity = player;
let components_0 = [
    world.get_component_id::<Unit>(),
    world.get_component_id::<Health>(),
    bk.get_component_id_unchecked(TypeId::of::<Relation<Attack>>()).flip_target(),
];

let components_1 = [
    world.get_component_id::<Unit>(),
    bk.get_component_id_unchecked(TypeId::of::<Relation<Attack>>()),
];

let archetype_id_sets = [
    bk.matching_archetypes(&components_0, &[]),
    Vec::new(),
];


// result set
const VAR_COUNT: usize = 2;
let mut a_refs = [&bk.archetypes[0]; VAR_COUNT];
let mut a_rows = [ArchetypeRow(u32::MAX); VAR_COUNT];

// general context for statemachine
let mut current_step = 1;
let mut a_max_rows = [0; VAR_COUNT];
let mut a_next_indexes = [usize::MAX; VAR_COUNT];
let mut col_indexes = [usize::MAX; 5];

{
    let (aid, arow) = bk.entities.get_archetype(invar_1);
    let a_ref = &mut a_refs[1];
    *a_ref = &bk.archetypes[aid.as_index()];
    a_ref.find_multiple_columns(&components_1, &mut col_indexes[3..5]);
    a_rows[1] = arow;
}

let mut rel_index_1 = 0;

::std::iter::from_fn(move || { loop { match current_step {
0 => {
    return None;
}

// follow relation
1 => {
    const CURRENT_VAR: usize = 1;
    const REL_VAR: usize = 0;
    const RELATION_COMP_INDEX: usize = 4;
    const REL_VAR_COMPONENTS: ::std::ops::Range<usize> = 0..3;
    let row = a_rows[CURRENT_VAR].0;
    let col = col_indexes[RELATION_COMP_INDEX];
    let arch = &a_refs[CURRENT_VAR];
    debug_assert_eq!(
        arch.columns[col].element_size(),
        size_of::<RelationVec>()
    );
    let ptr = unsafe { arch.columns[col].get(row) } as *const RelationVec;
    let rel_vec = unsafe { &*ptr };
    debug_assert!(rel_vec.len() > 0);
    if rel_index_1 >= rel_vec.len() {
        rel_index_1 = 0;
        current_step -= 1;
    } else {
        // get aid/row for entity in relation
        let id = EntityId(rel_vec[rel_index_1 as usize]);
        let (aid, arow) = bk.entities.get_archetype_unchecked(id);
        rel_index_1 += 1;

        // if in target archetype set => go to next step
        if archetype_id_sets[REL_VAR].contains(&aid) {
            let a_ref = &mut a_refs[REL_VAR];
            *a_ref = &bk.archetypes[aid.as_index()];
            a_ref.find_multiple_columns(
                &components_0,
                &mut col_indexes[REL_VAR_COMPONENTS],
            );
            a_rows[REL_VAR] = arow;

            current_step += 1;
        }
    }
}

// yield row
2 => {
    current_step -= 1;
    return Some(unsafe {
        (
            (&*((&a_refs[0].columns[col_indexes[0]]).get(a_rows[0].0)
                as *const RefCell<Unit>))
                .borrow(),
            (&*((&a_refs[1].columns[col_indexes[3]]).get(a_rows[1].0)
                as *const RefCell<Unit>))
                .borrow(),
            (&*((&a_refs[0].columns[col_indexes[1]]).get(a_rows[0].0)
                as *const RefCell<Health>))
                .borrow_mut(),
        )
    });
}

_ => unreachable!(),
}}})

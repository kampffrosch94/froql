---
source: froql_macro/src/generator.rs
expression: result
---
{

let world: &World = &world;
let bk = &world.bookkeeping;
let components_0 = [
    world.get_component_id::<Unit>(),
    world.get_component_id::<Health>(),
    bk.get_component_id_unchecked(TypeId::of::<Relation<Attack>>()).flip_target(),
];

let components_1 = [
    world.get_component_id::<Unit>(),
    bk.get_component_id_unchecked(TypeId::of::<Relation<Attack>>()),
];

let archetype_id_sets = [
    bk.matching_archetypes(&components_0, &[]),
    bk.matching_archetypes(&components_1, &[]),
];


// result set
const VAR_COUNT: usize = 2;
let mut a_refs = [&bk.archetypes[0]; VAR_COUNT];
let mut a_rows = [ArchetypeRow(u32::MAX); VAR_COUNT];

// general context for statemachine
let mut current_step = 0;
let mut a_max_rows = [0; VAR_COUNT];
let mut a_next_indexes = [usize::MAX; VAR_COUNT];
let mut col_indexes = [usize::MAX; 5];

let mut rel_index_2 = 0;

::std::iter::from_fn(move || { loop { match current_step {
0 => {
    const CURRENT_VAR: usize = 0;
    const CURRENT_VAR_COMPONENTS: ::std::ops::Range<usize> = 0..3;
    let next_index = &mut a_next_indexes[CURRENT_VAR];
    let archetype_ids = &archetype_id_sets[CURRENT_VAR];
    *next_index = next_index.wrapping_add(1);
    if *next_index >= archetype_ids.len() {
        return None;
    }
    let next_id = archetype_ids[*next_index];

    // gets rolled over to 0 by wrapping_add
    a_rows[CURRENT_VAR] = ArchetypeRow(u32::MAX);
    let a_ref = &mut a_refs[CURRENT_VAR];
    *a_ref = &bk.archetypes[next_id.as_index()];
    a_ref.find_multiple_columns(
        &components_0,
        &mut col_indexes[CURRENT_VAR_COMPONENTS],
    );
    a_max_rows[CURRENT_VAR] = a_ref.entities.len() as u32;
    current_step += 1;
}

// next row in archetype
1 => {
    const CURRENT_VAR: usize = 0;
    let row_counter = &mut a_rows[CURRENT_VAR].0;
    let max_row = a_max_rows[CURRENT_VAR];
    // rolls over to 0 for u32::MAX, which is our start value
    *row_counter = row_counter.wrapping_add(1);

    if *row_counter >= max_row {
        current_step -= 1;
    } else {
        current_step += 1;
    }
}

// follow relation
2 => {
    const CURRENT_VAR: usize = 0;
    const REL_VAR: usize = 1;
    const RELATION_COMP_INDEX: usize = 2;
    const REL_VAR_COMPONENTS: ::std::ops::Range<usize> = 3..5;
    let row = a_rows[CURRENT_VAR].0;
    let col = col_indexes[RELATION_COMP_INDEX];
    let arch = &a_refs[CURRENT_VAR];
    debug_assert_eq!(
        arch.columns[col].element_size(),
        size_of::<RelationVec>()
    );
    let ptr = unsafe { arch.columns[col].get(row) } as *const RelationVec;
    let rel_vec = unsafe { &*ptr };
    debug_assert!(rel_vec.len() > 0);
    if rel_index_2 >= rel_vec.len() {
        rel_index_2 = 0;
        current_step -= 1;
    } else {
        // get aid/row for entity in relation
        let id = EntityId(rel_vec[rel_index_2 as usize]);
        let (aid, arow) = bk.entities.get_archetype_unchecked(id);
        rel_index_2 += 1;

        // if in target archetype set => go to next step
        if archetype_id_sets[REL_VAR].contains(&aid) {
            let a_ref = &mut a_refs[REL_VAR];
            *a_ref = &bk.archetypes[aid.as_index()];
            a_ref.find_multiple_columns(
                &components_1,
                &mut col_indexes[REL_VAR_COMPONENTS],
            );
            a_rows[REL_VAR] = arow;

            if
                (::std::ptr::eq(a_refs[0], a_refs[1])
                 && a_rows[0] == a_rows[1])
            {
                current_step -= 1;
            } else {
                current_step += 1;
            }
        }
    }
}

// yield row
3 => {
    current_step -= 1;
    return Some(unsafe {
        (
            EntityViewDeferred::from_id_unchecked(world,
                                a_refs[0].entities[a_rows[0].0 as usize]),
            (&*((&a_refs[0].columns[col_indexes[0]]).get(a_rows[0].0)
                as *const RefCell<Unit>))
                .borrow(),
            (&*((&a_refs[1].columns[col_indexes[3]]).get(a_rows[1].0)
                as *const RefCell<Unit>))
                .borrow(),
            (&*((&a_refs[0].columns[col_indexes[1]]).get(a_rows[0].0)
                as *const RefCell<Health>))
                .borrow_mut(),
        )
    });
}

_ => unreachable!(),
}}})

}

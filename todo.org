* Query generation
** DONE uncomponents
CLOSED: [2025-01-14 Tue 11:00]
also known as negative component constraints
** DONE outvars
CLOSED: [2025-01-15 Wed 04:05]
~&this~
Simple change, but I also want to return entityviews.
Though I guess I can do that later still.
** DONE invars
CLOSED: [2025-01-17 Fri 14:41]
~*player~
I suspect this will be a bit more complicated.
I'll have to add a route to the code gone that populates the archetypes/rows of invars.
Should do that as the first step, instead of fetching an archetype from the possible set.
- [X] write manual query
- [X] capture invars
- [X] generate component sets for invars
- [X] prefill archetypes from invars
- [X] branch generator depending on if invars are used
  + step 0 and 1 can be replaced by one that just returns None
  + we need to start at step 1 then (follow Relations)
  + join order needs invars as already set instead of picking the most constrained var

** DONE anyvars
CLOSED: [2025-01-17 Fri 14:41]
- example: ~ChildOf(_, me)~
They only constrain the component set, but don't add any variables.
Shouldn't be too hard.
** DONE variable inequality constraints
CLOSED: [2025-01-19 Sun 13:31]
Examples:
- ~a != b~
- ~*a != b~
- ~a != *b~
- [X] check after following relation
- [X] check before iterating in case of invars
** DONE relation constraints
CLOSED: [2025-01-19 Sun 13:31]
- [X] manual query
- [X] check after following relation
- [X] test proc query relation constraint
- [X] check before iterating in case of invars
- [X] test proc query relation constraint invar
- [X] uncomment test case when done
** DONE optional components
CLOSED: [2025-01-21 Tue 22:58]
- [X] parser
- [X] var info
- [X] set on archetype init
- [X] set on relation join
- [X] set on invar init
- [X] write test for archetype init
- [X] write test for relation join
- [X] write test for invar init
- [X] use on yield
** DONE RelationHelper abstraction
CLOSED: [2025-02-02 Sun 14:43]
This is needed for allowing transitive relations in queries.
- [X] add RelationHelper to var in case of RelationConstraint
- [X] init fsm context
- [X] set col, set row in ArchetypeInit
- [X] set col, set row in InvarInit
- [X] set col, set row in RelationJoin
- [X] use for next in relation join
- [X] relation constraints in relation join
- [X] invar constraints
- [X] remove old variant
- [X] transitive relations
** DONE unrelations
CLOSED: [2025-02-09 Sun 10:29]
- ~!Rel(a,b)~
Similar to relation constraints and optional components
- [X] need to handle transitivity first
*** DONE unrelation with anyvar
CLOSED: [2025-02-07 Fri 10:23]
~!Rel(a,_)~
- this can be handled at the archetype constraint level
- an archetype just needs to not have this relation as component to qualify
*** DONE unrelation with regular vars and invars
CLOSED: [2025-02-09 Sun 10:29]
satisfied if either the component is not in the archetype
or if it exists it the RelVec does not contain the entity_id bound to the other var
- [X] compute place to insert relationhelper and check
- [X] init
- [X] check constraint on relation join
- [X] test
** DONE queries involving ZSTs
CLOSED: [2025-04-13 Sun 16:28]
- ZST are not stored in archetype
  - need to search for them when creating archetype sets
  - don't need them in output array, can just create from NonNull::dangling()
  - maybe I should insert checks that outputs are not ZSTs
- I think I'll just handle ZSTs like any type other so I don't end in type hell
- ended up doing just that
** TODO create Entities for components
- should those exist for relationships as well?
** TODO singletons
- ~mut $TileMap~ and ~$TileMap~
- singletons should be entities with only one component
- => need to add them to the component register
- probably good to add an API for them at the world/bk level before worrying about queries
** TODO work on a demo before continuing here
The possibilities for more and more involved queries are endless.
But at some point I need to actually try them out in the field and gain insights there.
** TODO mutable optional components
- [ ] parser: optional component with invar ~CompA(*me)?~
- [ ] parser for ~mut CompA?~, ~mut CompA(me)?~, ~mut CompA(*me)?~
- [ ] accessor for mutable
- [ ] test
** TODO dynamic tags
- tag relationship to component entity?
* World API
** DONE EntityViewMut
CLOSED: [2025-04-13 Sun 16:29]
** DONE EntityViewDeferred
CLOSED: [2025-04-13 Sun 16:29]
** TODO sync syntax
- <> sync before and after
- < sync before
- > sync after
- sync refers to calling world.process() here
* Interface testing
Should be in integration tests.
** TODO Adding the same component multiple times
Adding a new one should override the old one.
And call drop correctly.
** TODO ZSTs as components
- add, has, remove should all behave as expect
- get should panic
** TODO macro hygiene
Adding a query! macro should not require the user to add extra imports.
* CI setup
** Formatter
check that everything is nicely formatted or fail the build
** Insta
set ~export CI=true~ in CI
that is true by default for github actions afaik

* Publication
** Naming conventions
- what I called unchecked is often not really unchecked, it just doesn't have an EntityGeneration and calls via EntityId
** Write Readme
*** Goals
- single threaded
- fast compile time
- okayish runtime
- ergonomic API
*** Examples
*** Comparision to other solutions
*** Publish to crates.io


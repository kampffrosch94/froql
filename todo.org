* Query generation
** DONE uncomponents
CLOSED: [2025-01-14 Tue 11:00]
also known as negative component constraints
** DONE outvars
CLOSED: [2025-01-15 Wed 04:05]
~&this~
Simple change, but I also want to return entityviews.
Though I guess I can do that later still.
** DONE invars
CLOSED: [2025-01-17 Fri 14:41]
~*player~
I suspect this will be a bit more complicated.
I'll have to add a route to the code gone that populates the archetypes/rows of invars.
Should do that as the first step, instead of fetching an archetype from the possible set.
- [X] write manual query
- [X] capture invars
- [X] generate component sets for invars
- [X] prefill archetypes from invars
- [X] branch generator depending on if invars are used
  + step 0 and 1 can be replaced by one that just returns None
  + we need to start at step 1 then (follow Relations)
  + join order needs invars as already set instead of picking the most constrained var

** DONE anyvars
CLOSED: [2025-01-17 Fri 14:41]
- example: ~ChildOf(_, me)~
They only constrain the component set, but don't add any variables.
Shouldn't be too hard.
** TODO variable inequality constraints
Examples:
- ~a != b~
- ~*a != b~
- ~a != *b~
Inequality constraints are an additonal step that needs to be inserted in the generator.
In theory I could check inequalities also the moment I follow an relationship,
instead of actually creating an additional step :thonk:
In the case of invars I might need to check them even earlier.
-> easiest to just add another step though
-> should be part of the join order
** TODO unrelations
- ~!Rel(a,b)~
Should be an additional step that needs to be inserted.
** TODO singletons
- ~mut $TileMap~ and ~$TileMap~
- singletons should be entities with only one component
- => need to add them to the component register
- probably good to add an API for them at the world/bk level before worrying about queries
** TODO queries involving ZSTs
- ZST are not stored in archetype
  - need to search for them when creating archetype sets
  - don't need them in output array, can just create from NonNull::dangling()
  - maybe I should insert checks that outputs are not ZSTs
* World API
** TODO EntityViewMut
** TODO EntityViewDeferred
** TODO sync syntax
- <> sync before and after
- < sync before
- > sync after
- sync refers to calling world.process() here
* Interface testing
Should be in integration tests.
** TODO Adding the same component multiple times
Adding a new one should override the old one.
And call drop correctly.
** TODO ZSTs as components
- add, has, remove should all behave as expect
- get should panic
** TODO macro hygiene
Adding a query! macro should not require the user to add extra imports.
* CI setup
** Formatter
check that everything is nicely formatted or fail the build
** Insta
set ~export CI=true~ in CI

* Publication
** Write Readme
*** Goals
- single threaded
- fast compile time
- okayish runtime
- ergonomic API
*** Examples
*** Comparision to other solutions
*** Publish to crates.io

* Vocab
| term                 | explanation                                                                 | example                                        |
|----------------------+-----------------------------------------------------------------------------+------------------------------------------------|
| entity               | something that can have components and relationships                        |                                                |
| component            | a struct attached to an entity                                              | Health   (Health is a normal Rust type)        |
| relation             | a connection between two entities                                           | Friends(a,b)   (Friends is a normal Rust type) |
|----------------------+-----------------------------------------------------------------------------+------------------------------------------------|
| variable             | a standin for an entity in a query                                          | Health(this)                                   |
| component access     |                                                                             |                                                |
| mut component access |                                                                             |                                                |
| singleton            |                                                                             | todo                                           |
| outvar               | entity variable that should be returned by the query                        | &this                                          |
| invar                | a value for an entity that is passed into a query                           | Health(*me)                                    |
| constraint           | something that filters out results from a query                             | this != that                                   |
| uncomponent          | negative component constraint, filters out results where var has component  | !Health                                        |
| unrelation           | negative relation constraint, filters out results where Relation is present | !ChildOf(this, other)                          |
|----------------------+-----------------------------------------------------------------------------+------------------------------------------------|
| create               | creates an entity or entityview                                             | let e = world.create()                         |
| destroy              | removes an entity and cleans up its relations and components                | e.destruct()                                   |
|----------------------+-----------------------------------------------------------------------------+------------------------------------------------|
| add                  | adds a component to an entity                                               | e.add(Comp{})                                  |
| remove               | removes a component from an entity                                          | e.remove::<Comp>()                             |
|----------------------+-----------------------------------------------------------------------------+------------------------------------------------|
| relate               | creates a relation between two entities                                     | a.relate_to::<Friend>(b)                       |
| unrelate             | removes a relation between two entities                                     | a.unrelate_to::<Friend>(b)                     |
|----------------------+-----------------------------------------------------------------------------+------------------------------------------------|
| immediate            | a change of entities, components or relations is immediately executed       | e.add(Comp{}); (with a mutable EntityView)     |
| deferred             | a change is queued up until `World::process()` is called                    | e.add(Comp{}); (with a EntityViewDeferred)     |
|----------------------+-----------------------------------------------------------------------------+------------------------------------------------|
| exclusive            | Rel(a,b) gets removed when Rel(a,c) is created                              | todo                                           |
| reflexive            | Rel(a,b) also means Rel(b,a)                                                | todo                                           |
| transitive           | Rel(a,b) and Rel(b,c) means Rel(a,c) implicitly                             | todo                                           |
| cascade delete       | when a from Rel(a,b) gets destroyed, then b also gets destroyed             | todo                                           |

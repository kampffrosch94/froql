* Query generation
** DONE uncomponents
CLOSED: [2025-01-14 Tue 11:00]
also known as negative component constraints
** DONE outvars
CLOSED: [2025-01-15 Wed 04:05]
~&this~
Simple change, but I also want to return entityviews.
Though I guess I can do that later still.
** DONE invars
CLOSED: [2025-01-17 Fri 14:41]
~*player~
I suspect this will be a bit more complicated.
I'll have to add a route to the code gone that populates the archetypes/rows of invars.
Should do that as the first step, instead of fetching an archetype from the possible set.
- [X] write manual query
- [X] capture invars
- [X] generate component sets for invars
- [X] prefill archetypes from invars
- [X] branch generator depending on if invars are used
  + step 0 and 1 can be replaced by one that just returns None
  + we need to start at step 1 then (follow Relations)
  + join order needs invars as already set instead of picking the most constrained var

** DONE anyvars
CLOSED: [2025-01-17 Fri 14:41]
- example: ~ChildOf(_, me)~
They only constrain the component set, but don't add any variables.
Shouldn't be too hard.
** DONE variable inequality constraints
CLOSED: [2025-01-19 Sun 13:31]
Examples:
- ~a != b~
- ~*a != b~
- ~a != *b~
- [X] check after following relation
- [X] check before iterating in case of invars
** DONE relation constraints
CLOSED: [2025-01-19 Sun 13:31]
- [X] manual query
- [X] check after following relation
- [X] test proc query relation constraint
- [X] check before iterating in case of invars
- [X] test proc query relation constraint invar
- [X] uncomment test case when done
** DONE optional components
CLOSED: [2025-01-21 Tue 22:58]
- [X] parser
- [X] var info
- [X] set on archetype init
- [X] set on relation join
- [X] set on invar init
- [X] write test for archetype init
- [X] write test for relation join
- [X] write test for invar init
- [X] use on yield
** DONE RelationHelper abstraction
CLOSED: [2025-02-02 Sun 14:43]
This is needed for allowing transitive relations in queries.
- [X] add RelationHelper to var in case of RelationConstraint
- [X] init fsm context
- [X] set col, set row in ArchetypeInit
- [X] set col, set row in InvarInit
- [X] set col, set row in RelationJoin
- [X] use for next in relation join
- [X] relation constraints in relation join
- [X] invar constraints
- [X] remove old variant
- [X] transitive relations
** DONE unrelations
CLOSED: [2025-02-09 Sun 10:29]
- ~!Rel(a,b)~
Similar to relation constraints and optional components
- [X] need to handle transitivity first
*** DONE unrelation with anyvar
CLOSED: [2025-02-07 Fri 10:23]
~!Rel(a,_)~
- this can be handled at the archetype constraint level
- an archetype just needs to not have this relation as component to qualify
*** DONE unrelation with regular vars and invars
CLOSED: [2025-02-09 Sun 10:29]
satisfied if either the component is not in the archetype
or if it exists it the RelVec does not contain the entity_id bound to the other var
- [X] compute place to insert relationhelper and check
- [X] init
- [X] check constraint on relation join
- [X] test
** TODO queries involving ZSTs
- ZST are not stored in archetype
  - need to search for them when creating archetype sets
  - don't need them in output array, can just create from NonNull::dangling()
  - maybe I should insert checks that outputs are not ZSTs
- I think I'll just handle ZSTs like any type other so I don't end in type hell
** TODO create Entities for components
- should those exist for relationships as well?
** TODO singletons
- ~mut $TileMap~ and ~$TileMap~
- singletons should be entities with only one component
- => need to add them to the component register
- probably good to add an API for them at the world/bk level before worrying about queries
** TODO work on a demo before continuing here
The possibilities for more and more involved queries are endless.
But at some point I need to actually try them out in the field and gain insights there.
** TODO mutable optional components
- [ ] parser: optional component with invar ~CompA(*me)?~
- [ ] parser for ~mut CompA?~, ~mut CompA(me)?~, ~mut CompA(*me)?~
- [ ] accessor for mutable
- [ ] test
** TODO dynamic tags
- tag relationship to component entity?
* World API
** TODO EntityViewMut
** TODO EntityViewDeferred
** TODO sync syntax
- <> sync before and after
- < sync before
- > sync after
- sync refers to calling world.process() here
* Interface testing
Should be in integration tests.
** TODO Adding the same component multiple times
Adding a new one should override the old one.
And call drop correctly.
** TODO ZSTs as components
- add, has, remove should all behave as expect
- get should panic
** TODO macro hygiene
Adding a query! macro should not require the user to add extra imports.
* CI setup
** Formatter
check that everything is nicely formatted or fail the build
** Insta
set ~export CI=true~ in CI

* Publication
** Write Readme
*** Goals
- single threaded
- fast compile time
- okayish runtime
- ergonomic API
*** Examples
*** Comparision to other solutions
*** Publish to crates.io

* Vocab
| term                 | explanation                                                                 | example                                        |
|----------------------+-----------------------------------------------------------------------------+------------------------------------------------|
| entity               | something that can have components and relationships                        |                                                |
| component            | a struct attached to an entity                                              | Health   (Health is a normal Rust type)        |
| relation             | a connection between two entities                                           | Friends(a,b)   (Friends is a normal Rust type) |
|----------------------+-----------------------------------------------------------------------------+------------------------------------------------|
| variable             | a standin for an entity in a query                                          | Health(this)                                   |
| component access     |                                                                             |                                                |
| mut component access |                                                                             |                                                |
| singleton            |                                                                             | todo                                           |
| outvar               | entity variable that should be returned by the query                        | &this                                          |
| invar                | a value for an entity that is passed into a query                           | Health(*me)                                    |
| constraint           | something that filters out results from a query                             | this != that                                   |
| uncomponent          | negative component constraint, filters out results where var has component  | !Health                                        |
| unrelation           | negative relation constraint, filters out results where Relation is present | !ChildOf(this, other)                          |
|----------------------+-----------------------------------------------------------------------------+------------------------------------------------|
| create               | creates an entity or entityview                                             | let e = world.create()                         |
| destroy              | removes an entity and cleans up its relations and components                | e.destruct()                                   |
|----------------------+-----------------------------------------------------------------------------+------------------------------------------------|
| add                  | adds a component to an entity                                               | e.add(Comp{})                                  |
| remove               | removes a component from an entity                                          | e.remove::<Comp>()                             |
|----------------------+-----------------------------------------------------------------------------+------------------------------------------------|
| relate               | creates a relation between two entities                                     | a.relate_to::<Friend>(b)                       |
| unrelate             | removes a relation between two entities                                     | a.unrelate_to::<Friend>(b)                     |
|----------------------+-----------------------------------------------------------------------------+------------------------------------------------|
| immediate            | a change of entities, components or relations is immediately executed       | e.add(Comp{}); (with a mutable EntityView)     |
| deferred             | a change is queued up until `World::process()` is called                    | e.add(Comp{}); (with a EntityViewDeferred)     |
|----------------------+-----------------------------------------------------------------------------+------------------------------------------------|
| exclusive            | Rel(a,b) gets removed when Rel(a,c) is created                              | todo                                           |
| reflexive            | Rel(a,b) also means Rel(b,a)                                                | todo                                           |
| transitive           | Rel(a,b) and Rel(b,c) means Rel(a,c) implicitly                             | todo                                           |
| cascade delete       | when a from Rel(a,b) gets destroyed, then b also gets destroyed             | todo                                           |
